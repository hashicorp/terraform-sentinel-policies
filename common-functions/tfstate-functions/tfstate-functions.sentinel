# Common functions that use the tfstate/v2 import

# The filter functions all accept a collection of resources, an attribute,
# a value or a list of values, and a boolean, prtmsg, which can be true or false
# and indicates whether the filter function should print violation messages.
# The filter functions return a map consisting of 2 items:
#   * "resources": a map consisting of resources that violate a condition
#   * "messages":  a map of violation messages associated with the resources
# Note that both the resources and messages collections are indexed by the
# address of the resources, so they will have the same order and length.
# The filter functions all call evaluate_attribute() to evaluate attributes
# of resources even if nested deep within them.

##### Imports #####
import "tfstate/v2" as tfstate
import "strings"
import "types"

##### Functions #####

### find_resources ###
# Find all resources of a specific type using the tfstate/v2 import.
find_resources = func(type) {
	resources = filter tfstate.resources as address, r {
		r.type is type and
			r.mode is "managed"
	}

	return resources
}

### find_resources_by_provider ###
# Find all resources for a specific provider using the tfstate/v2 import.
# Terraform 0.12 and earlier set `r.provider_name` to short text like "null";
# but Terraform 0.13 and higher set it to something like
# "registry.terraform.io/hashicorp/null".
# You can pass in the long form or short form.
find_resources_by_provider = func(provider) {
	parsed_provider = strings.split(provider, "/")
	segment_count = length(parsed_provider)
	v = strings.split(tfstate.terraform_version, ".")
	v_major = int(v[1])

	# If v_major is 12, we know short form was passed to Sentinel
	if v_major is 12 {
		resources = filter tfstate.resources as address, r {
			r.provider_name is provider and
				r.mode is "managed"
		}
	} else {
		# v_major must be higher than 12 since v2 imports being used
		# So, we know long form like "registry.terraform.io/hashicorp/null" given
		if segment_count is 1 {
			# Function was passed short form, so we want to reduce each occurence of
			# r.provider_name to its short form.
			resources = filter tfstate.resources as address, r {
				strings.split(r.provider_name, "/")[2] is provider and
					r.mode is "managed"
			}
		} else {
			# Function was passed long form, so we use full r.provider_name
			resources = filter tfstate.resources as address, r {
				r.provider_name is provider and
					r.mode is "managed"
			}
		} // end segment_count
	} // end v_major

	return resources
}

### find_datasources ###
# Find all data sources of a specific type using the tfstate/v2 import.
find_datasources = func(type) {
	datasources = filter tfstate.resources as address, d {
		d.type is type and
			d.mode is "data"
	}

	return datasources
}

### find_datasources_by_provider ###
# Find all data sources for a specific provider using the tfstate/v2 import.
# Terraform 0.12 and earlier set `r.provider_name` to short text like "null";
# but Terraform 0.13 and higher set it to something like
# "registry.terraform.io/hashicorp/null".
# You can pass in the long form or short form.
find_datasources_by_provider = func(provider) {
	parsed_provider = strings.split(provider, "/")
	segment_count = length(parsed_provider)
	v = strings.split(tfstate.terraform_version, ".")
	v_major = int(v[1])

	# If v_major is 12, we know short form was passed to Sentinel
	if v_major is 12 {
		datasources = filter tfstate.resources as address, r {
			r.provider_name is provider and
				r.mode is "data"
		}
	} else {
		# v_major must be higher than 12 since v2 imports being used
		# So, we know long form like "registry.terraform.io/hashicorp/null" given
		if segment_count is 1 {
			# Function was passed short form, so we want to reduce each occurence of
			# r.provider_name to its short form.
			datasources = filter tfstate.resources as address, r {
				strings.split(r.provider_name, "/")[2] is provider and
					r.mode is "data"
			}
		} else {
			# Function was passed long form, so we use full r.provider_name
			datasources = filter tfstate.resources as address, r {
				r.provider_name is provider and
					r.mode is "data"
			}
		} // end segment_count
	} // end v_major

	return datasources
}

### find_blocks ###
# Find all blocks of a specific type from a resource using the tfstate/v2 import.
# parent should be a single resource or block of a resource or a data source
# or block of a data source.
# If parent is a resource, you can pass it in the form r.values or just r.
# child should be a string representing a block of parent
# that contains a list of objects.
find_blocks = func(parent, child) {
	# Use parent.values if it exists
	if (types.type_of(parent) is "map" and
		"values" in keys(parent)) and
		types.type_of(parent.values) is "map" {
		if types.type_of(parent.values[child] else null) is "list" {
			return parent.values[child]
		} else {
			return []
		}
	} else {
		if types.type_of(parent[child] else null) is "list" {
			return parent[child]
		} else {
			return []
		}
	}
}

### to_string ###
# Convert objects of unknown type to string
# It is used to build messages added to the messages map returned by the
# filter functions
to_string = func(obj) {
	case types.type_of(obj) {
		when "string":
			return obj
		when "int", "float", "bool":
			return string(obj)
		when "null":
			return "null"
		when "undefined":
			return "undefined"
		when "list":
			output = "["
			lastIndex = length(obj) - 1
			for obj as index, value {
				if index < lastIndex {
					output += to_string(value) + ", "
				} else {
					output += to_string(value)
				}
			}
			output += "]"
			return output
		when "map":
			output = "{"
			theKeys = keys(obj)
			lastIndex = length(theKeys) - 1
			for theKeys as index, key {
				if index < lastIndex {
					output += to_string(key) + ": " + to_string(obj[key]) + ", "
				} else {
					output += to_string(key) + ": " + to_string(obj[key])
				}
			}
			output += "}"
			return output
		else:
			return ""
	}
}

### evaluate_attribute ###
# Evaluates the value of a resource's or block's attribute even if nested.
# The resource should be given in the initial call in the form
# "r.values" where r is a resource derived by
# applying filters to tfstate.resources.
# Indices of lists should be given as 0, 1, 2, and so on.
# For example: boot_disk.0.initialize_params.0.image
evaluate_attribute = func(r, attribute) {

	# Split the attribute into a list, using "." as the separator
	attributes = strings.split(attribute, ".")

	# Convert numeric strings to integers for indices
	if attributes[0] matches "^[0-9]+$" {
		a = int(attributes[0])
		# Make sure r is of type list
		if types.type_of(r) is not "list" {
			return undefined
		}
	} else {
		a = attributes[0]
	}

	# Append the current attribute to the resource instance
	new_r = r[a] else null

	# Append the current attribute to the resource instance
	# We check if r is a map having `values` (also a map) and `module_address`, so
	# that filter functions can pass in `r` instead of `r.values`.
	# The extra check for `module_address` is meant to make sure that `r`
	# is really a resource from the tfstate/v2 resources collection rather than
	# some block which just happens to have a key called `values`.
	# An example of such a block is the `filters` block of the `aws_ami` data source.
	if types.type_of(r) is "map" and
		"values" in keys(r) and
		types.type_of(r.values) is "map" and
		"module_address" in keys(r) {
		new_r = r.values[a] else null
	} else {
		new_r = r[a] else null
	}

	# Process based on length of attributes
	# being greater than or equal to 1
	if length(attributes) > 1 {

		# Strip first element from attributes
		attributes = attributes[1:length(attributes)]
		attribute = strings.join(attributes, ".")

		# Make recursive call
		return evaluate_attribute(new_r, attribute)
	} else {

		# We reached the end of the attribute and can stop the
		# recursive calls and return the value of the attribute
		return new_r

	}
}

### print_violations ###
# Prints violations returned by any of the filter functions defined below.
# This would normally only be called if the filter function had been called
# with prtmsg set to false, which is sometimes done when processing resources
# and their blocks.
# If the result of a filter function is assigned to a map like violatingIRs,
# then you should pass violatingIRs["message"] as the first argument.
# The prefix argument is printed before the message of each resource.
print_violations = func(messages, prefix) {
	for messages as address, message {
		print(prefix, message)
	}
	return true
}

### filter_attribute_not_in_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that is not in a given list of allowed values (allowed).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to allow null, include "null" in the list (allowed).
filter_attribute_not_in_list = func(resources, attr, allowed, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (v) of the attribute
		v = evaluate_attribute(r, attr) else null
		# Convert null to "null"
		if v is null {
			v = "null"
		}
		# Check if the value is not in the allowed list
		if v not in allowed {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is not in the allowed list: " +
				to_string(allowed)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} // end if
	} // end for
	return {"items": violators, "messages": messages}
}

### filter_attribute_in_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that is in a given list of forbidden values (forbidden).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
filter_attribute_in_list = func(resources, attr, forbidden, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (v) of the attribute
		v = evaluate_attribute(r, attr) else null
		# Check if the value is null
		if v is null {
			v = "null"
		}
		# Check if the value is in the forbidden list
		if v in forbidden {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is in the forbidden list: " +
				to_string(forbidden)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_not_contains_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that does not contain a given list of required values (required).
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# Resources should be derived by applying filters to tfstate.resources.
filter_attribute_not_contains_list = func(resources, attr, required, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (v) of the attribute
		v = evaluate_attribute(r, attr) else null
		# Check if the value contains the desired allowed list
		if v is null or
			not (types.type_of(v) is "list" or types.type_of(v) is "map") {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is missing, null, or is not a map or a list. " +
				"It should have had these items: " +
				to_string(required)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else {
			missing_values = []
			for required as rv {
				if v not contains rv {
					append(missing_values, rv)
				} // end if
			} // end for required
			if length(missing_values) > 0 {
				# Build warning message when v is a map
				message = to_string(address) + " has " + to_string(attr) + " " +
					to_string(v) +
					" that is missing the required items " +
					to_string(missing_values) +
					" from the list: " +
					to_string(required)
				# Add the resource and warning message to the violators list
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			} // end length(missing_values)
		} // end else v not null
	} // end for
	return {"items": violators, "messages": messages}
}

### filter_attribute_contains_items_from_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that contains any items from a given list of
# forbidden values (forbidden).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
filter_attribute_contains_items_from_list = func(resources, attr, forbidden, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (v) of the attribute
		v = evaluate_attribute(r, attr) else null
		# Check if the value contains the desired allowed list
		if not (types.type_of(v) is "list" or types.type_of(v) is "map" or
			types.type_of(v) is "null") {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " " +
				to_string(v) +
				" that is not a map, a list, or null"
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if v is null {
			if "null" in forbidden {
				# Add the resource and a warning message to the violators list
				message = to_string(address) + " has " + to_string(attr) +
					" with value null from the forbidden list: " +
					to_string(forbidden)
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			}
		} else {
			forbidden_values = []
			for forbidden as fv {
				if v contains fv {
					append(forbidden_values, fv)
				} // end if
			} // end for forbidden
			if length(forbidden_values) > 0 {
				# Build warning message when v is a list
				message = to_string(address) + " has " + to_string(attr) + " " +
					to_string(v) +
					" that has items " +
					to_string(forbidden_values) +
					" from the forbidden list: " +
					to_string(forbidden)
				# Add the resource and a warning message to the violators list
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			} // end length(forbidden_values)
		} // end v not null
	} // end for
	return {"items": violators, "messages": messages}
}

### lowercase_list_contents ###
# A helper function to facilitate checking against lowercase versions of lists
# for situations where case is important, such as IAM policies.
# useful for lists generated by evaluate_attribute
lowercase_list_contents = func(items) {
	result = []
	for items as item {
		append(result, strings.to_lower(item))
	}
	return result
}

### case_insensitive_filter_attribute_contains_items_from_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that contains any items from a given case-insensitive list of
# forbidden values (forbidden).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
case_insensitive_filter_attribute_contains_items_from_list = func(resources, attr, forbidden, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (v) of the attribute
		v = evaluate_attribute(r, attr) else null
		# Check if the value contains the desired allowed list
		if not (types.type_of(v) is "list" or types.type_of(v) is "map" or
			types.type_of(v) is "null") {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " " +
				to_string(v) +
				" that is not a map, a list, or null"
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if v is null {
			if "null" in forbidden {
				# Add the resource and a warning message to the violators list
				message = to_string(address) + " has " + to_string(attr) +
					" with value null from the forbidden list: " +
					to_string(forbidden)
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			}
		} else {
			forbidden_values = []
			lc_v = lowercase_list_contents(v)
			for forbidden as fv {
				if lc_v contains strings.to_lower(fv) {
					append(forbidden_values, fv)
				} // end if
			} // end for forbidden
			if length(forbidden_values) > 0 {
				# Build warning message when v is a list
				message = to_string(address) + " has " + to_string(attr) + " " +
					to_string(v) +
					" that has items " +
					to_string(forbidden_values) +
					" from the forbidden list: " +
					to_string(forbidden)
				# Add the resource and a warning message to the violators list
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			} // end length(forbidden_values)
		} // end v not null
	} // end for
	return {"items": violators, "messages": messages}
}

### filter_attribute_contains_items_not_in_list ###
# Filter a list of resources to those with a specified
# attribute (attr) that contains items not in a given list of allowed values.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to allow null, include "null" in the list (allowed).
filter_attribute_contains_items_not_in_list = func(resources, attr, allowed, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		# Evaluate the value (vals) of the attribute
		vals = evaluate_attribute(r, attr) else null
		# Check if the value contains items not in allowed list
		if not (types.type_of(vals) is "list" or types.type_of(vals) is "map" or
			types.type_of(vals) is "null") {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " " +
				to_string(vals) +
				" that is not a map, a list, or null"
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if vals is null {
			if "null" not in allowed {
				# Add the resource and a warning message to the violators list
				message = to_string(address) + " has " + to_string(attr) +
					" with value null " +
					"that is not in the allowed list: " +
					to_string(allowed)
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			}
		} else {
			forbidden_values = []
			for vals as v {
				if v not in allowed {
					append(forbidden_values, v)
				} // end if v not allowed
			} // end for vals
			if length(forbidden_values) > 0 {
				# Build warning message when vals is a map
				message = to_string(address) + " has " + to_string(attr) + " " +
					to_string(vals) +
					" with items " +
					to_string(forbidden_values) +
					" that are not in the allowed list: " +
					to_string(allowed)
				# Add the resource and a warning message to the violators list
				violators[address] = r
				messages[address] = message
				if prtmsg {
					print(message)
				}
			} // end length(forbidden_values)
		} // end if null
	} // end for
	return {"items": violators, "messages": messages}
}

### filter_attribute_is_not_value ###
# Filter a list of resources to those with a specified
# attribute (attr) that does not have a given value.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_is_not_value = func(resources, attr, value, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It is supposed to be " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if v is not value {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is not equal to " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_is_value ###
# Filter a list of resources to those with a specified
# attribute (attr) that has a given value.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to match null, set value to "null".
filter_attribute_is_value = func(resources, attr, value, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			v = "null"
		}
		if v is value {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is not allowed."
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_greater_than_value ###
# Filter a list of resources to those with a specified
# attribute (attr) that is greater than a given numeric value.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_greater_than_value = func(resources, attr, value, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if float(v) else null is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It is supposed to be less " +
				"than or equal to " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if float(v) > value {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is greater than " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_less_than_value ###
# Filter a list of resources to those with a specified
# attribute (attr) that is less than a given numeric value.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_less_than_value = func(resources, attr, value, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if float(v) else null is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It is supposed to be greater " +
				"than or equal to " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if float(v) < value {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is less than " +
				to_string(value)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_does_not_match_regex ###
# Filter a list of resources to those with a specified
# attribute (attr) that does not match a regular expression (expr).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to allow null, set `expr` to "(<regex>|null)".
filter_attribute_does_not_match_regex = func(resources, attr, expr, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			v = "null"
		}
		if v not matches expr {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that does not match the regex " +
				to_string(expr)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_matches_regex ###
# Filter a list of resources to those with a specified
# attribute (attr) that matches a regular expression (expr).
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to match null, set expr to "null".
filter_attribute_matches_regex = func(resources, attr, expr, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			v = "null"
		}
		if v matches expr {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that matches the regex " +
				to_string(expr)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_does_not_have_prefix ###
# Filter a list of resources to those with a specified
# attribute (attr) that does not have a given prefix.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_does_not_have_prefix = func(resources, attr, prefix, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It must have a value that " +
				"starts with " +
				to_string(prefix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if not strings.has_prefix(v, prefix) {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that does not have the prefix " +
				to_string(prefix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_has_prefix ###
# Filter a list of resources to those with a specified
# attribute (attr) that has a given prefix.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_has_prefix = func(resources, attr, prefix, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It must have a value that " +
				"does not start with " +
				to_string(prefix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if strings.has_prefix(v, prefix) {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that has the prefix " +
				to_string(prefix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_does_not_have_suffix ###
# Filter a list of resources to those with a specified
# attribute (attr) that does not have a given suffix.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_does_not_have_suffix = func(resources, attr, suffix, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It must have a value that " +
				"ends with " +
				to_string(prefix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if not strings.has_suffix(v, suffix) {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that does not have the suffix " +
				to_string(suffix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}

### filter_attribute_has_suffix ###
# Filter a list of resources to those with a specified
# attribute (attr) that has a given suffix.
# Resources should be derived by applying filters to tfstate.resources.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
filter_attribute_has_suffix = func(resources, attr, suffix, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, r {
		v = evaluate_attribute(r, attr) else null
		if v is null {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) +
				" that is null or undefined. " +
				"It must have a value that " +
				"does not end with " +
				to_string(suffix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		} else if strings.has_suffix(v, suffix) {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that has the suffix " +
				to_string(suffix)
			violators[address] = r
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"items": violators, "messages": messages}
}
